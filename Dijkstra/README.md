# Поиск кратчайшего пути в распределённой системе

В этом задании вы реализуете алгоритм поиска кратчайшего пути от узла-инициатора до каждого узла распределённой системы.

## Постановка задачи

В файле [`DijkstraProcess.java`](src/main/java/solution/DijkstraProcess.java) находится описание интерфейса, 
который вам предстоит реализовать. Свой код вы должны писать на языке Java в файле 
[`DijkstraProcessImpl.java`](src/main/java/solution/DijkstraProcessImpl.java).

### Окружение процесса

В этом задании распределённая система рассматривается как ориентированный взвешенный граф, в котором у каждого 
процесса `v` есть множество соседей `N(v)`.

Каждому из процессов системы будет присвоен уникальный идентификатор. Через ссылку на объект
[`Environment`](src/main/java/internal/Environment.java) ваш процесс
может узнать конфигурацию системы, общаться с другими процессами и сообщать об останове диффундирующего вычисления:

* `env.getProcessId()` &mdash; возвращается идентификатор вашего процесса.
* `env.getNeighbours` &mdash; возвращает множество процессов-соседей вашего процесса, при этом для каждого 
процесса-соседа указан его идентификатор и расстояние от вашего процесса до этого соседа.
* `env.send(dstId, message)` &mdash; посылает сообщение процессу с идентификатором `dstId`. 
При этом топология сети неполная: процесс `v` может послать сообщение процессу `u` только если `u` является соседом 
`v`, либо `v` является соседом `u`.
* `env.finishExecution()` &mdash; сообщает о завершении вычисления. Этот метод может быть вызван лишь один раз, 
после чего вычисление будет считаться завершённым.

Методы вашего класса [`DijkstraProcessImpl`](src/main/java/solution/DijkstraProcessImpl.java)
будут вызываться в следующих случаях:

* `onMessage(srcId, message)` &mdash; вызывается при получении сообщения от другого процесса с номером `srcId`.
  Между каждой парой процессов гарантируется FIFO порядок передачи сообщений.
* `startComputation()` &mdash; сообщает данному процессу, что он должен стать инициатором в алгоритме вычисления 
кратчайшего пути. Гарантируется, что только один процесс будет выбран инициатором.
* `getDistance()` &mdash; вызывается после завершения вычисления. Процесс должен вернуть кратчайшее расстояние 
от инициатора до этого процесса, или `null`, если не существует пути от инициатора до этого процесса.


## Работа с сообщениями

Каждое отправленное сообщение должно быть сериализуемо. Описание класса сообщений может выглядеть, например, так:

```java
record MyMessage(int key, String value) 
        implements java.io.Serializable {
}
```

Размер каждого отправленного сообщения не должен превышать двухсот байт.

Заметьте, что метод `onMessage(int senderPid, Object message)`в качестве аргумента принимает не описанный
вами тип сообщения, а `java.lang.Object`. Используйте приведения типов вида
```java 
MyMessage typedMessage = (MyMessage) message;
```
и, если нужно, оператор `instanceof`

```java
if (message instanceof MyMessage) {
    // ...
}
```

для приведения сообщения к нужному вам типу.

## Тестирование

Тестирования реализации происходит путем запуска теста [`DijkstraProcessTest.java`](src/test/java/solution/DijkstraProcessTest.java)

Из командной строки: `./gradlew test --tests solution*`
